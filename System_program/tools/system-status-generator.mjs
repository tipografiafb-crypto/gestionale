#!/usr/bin/env node

// System Status Generator
// Generates SYSTEM_STATUS.md with key metrics and health indicators

import { promises as fs } from "fs";
import path from "path";

const ROOT = process.argv[2] || ".";

function generateSystemStatus(modules, hooks, events, dependencies, featureSlices) {
  const timestamp = new Date().toISOString();
  const stats = calculateSystemStats(modules, hooks, events, dependencies, featureSlices);
  const exportStats = generateExportIdempotencyStats();
  
  return `# SYSTEM STATUS

> Last generated: ${timestamp}  
> Generated by: \`tools/build-universal-mapping.mjs\`

## ðŸ“Š System Health Overview

| Metric | Count | Status |
|---|---|---|
| **Total Modules** | ${stats.totalModules} | ${getHealthIndicator(stats.totalModules, 50, 100)} |
| **Active Features** | ${stats.activeFeatures} | ${getHealthIndicator(stats.activeFeatures, 8, 15)} |
| **WordPress Hooks** | ${stats.totalHooks} | ${getHealthIndicator(stats.totalHooks, 20, 50)} |
| **JS Events** | ${stats.totalEvents} | ${getHealthIndicator(stats.totalEvents, 15, 30)} |
| **Dependencies** | ${stats.totalDependencies} | ${getHealthIndicator(stats.totalDependencies, 30, 60)} |
| **High Risk Modules** | ${stats.highRiskModules} | ${stats.highRiskModules > 10 ? 'ðŸ”´ HIGH' : stats.highRiskModules > 5 ? 'ðŸŸ¡ MEDIUM' : 'ðŸŸ¢ LOW'} |

## ðŸš€ Export Performance Metrics

| Metric | Value | Status |
|---|---|---|
| **Export Jobs Processed** | ${exportStats.totalJobs || 0} | ${exportStats.totalJobs > 0 ? 'ðŸŸ¢ ACTIVE' : 'ðŸŸ¡ IDLE'} |
| **Duplicates Prevented** | ${exportStats.duplicatesPrevented || 0} (${exportStats.duplicatePercentage || '0.0'}%) | ${(exportStats.duplicatesPrevented || 0) > 0 ? 'ðŸŸ¢ WORKING' : 'ðŸŸ¡ NONE'} |
| **Cache Hit Rate** | ${exportStats.cacheHits || 0} (${exportStats.cacheHitPercentage || '0.0'}%) | ${parseFloat(exportStats.cacheHitPercentage || 0) > 20 ? 'ðŸŸ¢ EFFICIENT' : 'ðŸŸ¡ LOW'} |
| **Average Export Time** | ${exportStats.averageJobTimeFormatted || '0ms'} | ${parseFloat(exportStats.averageJobTime || 0) < 1000 ? 'ðŸŸ¢ FAST' : parseFloat(exportStats.averageJobTime || 0) < 3000 ? 'ðŸŸ¡ MODERATE' : 'ðŸ”´ SLOW'} |
| **Active Export Jobs** | ${exportStats.activeMutexes || 0} | ${(exportStats.activeMutexes || 0) > 5 ? 'ðŸ”´ HIGH LOAD' : 'ðŸŸ¢ NORMAL'} |
| **Cache Size** | ${exportStats.cacheSize || 0} entries | ${(exportStats.cacheSize || 0) > 40 ? 'ðŸŸ¡ FULL' : 'ðŸŸ¢ HEALTHY'} |

## ðŸŽ¯ Feature Distribution

${generateFeatureTable(stats.featureStats)}

## âš ï¸ Risk Assessment

### Critical Risk Modules (${stats.criticalRiskModules})
${stats.criticalModules.map(m => `- **${m.module}** (\`${m.path}\`) - ${m.purpose}`).join('\n') || '- None'}

### High Risk Modules (${stats.highRiskModules})
${stats.highRiskModules > 0 ? stats.highRiskModulesList.slice(0, 5).map(m => `- **${m.module}** (\`${m.path}\`) - ${m.feature || 'no-feature'}`).join('\n') : '- None'}

## ðŸ”— Dependency Health

### Top Dependencies (Most Referenced)
${generateTopDependencies(stats.dependencyStats)}

### Modules with High Fan-Out (${stats.highFanOutModules})
${stats.highFanOutList.map(item => `- **${item.module}**: ${item.count} dependencies`).join('\n') || '- None'}

## ðŸ“ˆ System Complexity Indicators

| Indicator | Value | Threshold | Status |
|---|---|---|---|
| **Avg Hooks per Module** | ${(stats.totalHooks / stats.totalModules).toFixed(1)} | < 3.0 | ${(stats.totalHooks / stats.totalModules) < 3 ? 'ðŸŸ¢' : 'ðŸŸ¡'} |
| **Avg Events per Module** | ${(stats.totalEvents / stats.totalModules).toFixed(1)} | < 2.0 | ${(stats.totalEvents / stats.totalModules) < 2 ? 'ðŸŸ¢' : 'ðŸŸ¡'} |
| **Feature Coupling** | ${stats.featureCoupling.toFixed(1)}% | < 20% | ${stats.featureCoupling < 20 ? 'ðŸŸ¢' : stats.featureCoupling < 40 ? 'ðŸŸ¡' : 'ðŸ”´'} |
| **Risk Distribution** | ${stats.riskDistribution} | Balanced | ${isRiskBalanced(stats.riskCounts) ? 'ðŸŸ¢' : 'ðŸŸ¡'} |

## ðŸ—ï¸ Architecture Insights

### Module Stability
- **HIGH**: ${stats.stabilityStats.HIGH || 0} modules
- **MEDIUM**: ${stats.stabilityStats.MEDIUM || 0} modules  
- **LOW**: ${stats.stabilityStats.LOW || 0} modules
- **UNKNOWN**: ${stats.stabilityStats.UNKNOWN || 0} modules

### Recent Changes Impact
${stats.recentChangesImpact}

## ðŸŽ¯ Action Items

${generateActionItems(stats, exportStats)}

---

### Legend
- ðŸŸ¢ Healthy | ðŸŸ¡ Monitor | ðŸ”´ Action Required
- **Fan-out**: Number of dependencies a module has
- **Fan-in**: Number of modules that depend on this module
- **Feature Coupling**: Percentage of modules that span multiple features
`;
}

function calculateSystemStats(modules, hooks, events, dependencies, featureSlices) {
  const stats = {
    totalModules: modules.length,
    totalHooks: hooks.length,
    totalEvents: events.length,
    totalDependencies: dependencies.length,
    activeFeatures: Object.keys(featureSlices).length
  };
  
  // Risk analysis
  stats.riskCounts = modules.reduce((acc, m) => {
    const risk = m.risk || 'UNKNOWN';
    acc[risk] = (acc[risk] || 0) + 1;
    return acc;
  }, {});
  
  stats.highRiskModules = stats.riskCounts.HIGH || 0;
  stats.criticalRiskModules = stats.riskCounts.CRITICAL || 0;
  stats.criticalModules = modules.filter(m => m.risk === 'CRITICAL');
  stats.highRiskModulesList = modules.filter(m => m.risk === 'HIGH');
  
  // Feature stats
  stats.featureStats = Object.entries(featureSlices).map(([feature, data]) => ({
    feature,
    modules: data.stats.moduleCount,
    hooks: data.stats.hookCount,
    events: data.stats.eventCount,
    risk: data.stats.riskLevels
  }));
  
  // Dependency analysis
  const depCount = dependencies.reduce((acc, dep) => {
    acc[dep.dependency] = (acc[dep.dependency] || 0) + 1;
    return acc;
  }, {});
  
  stats.dependencyStats = Object.entries(depCount)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10);
  
  // Fan-out analysis (modules with many dependencies)
  const moduleDeps = dependencies.reduce((acc, dep) => {
    acc[dep.file] = (acc[dep.file] || 0) + 1;
    return acc;
  }, {});
  
  stats.highFanOutModules = Object.values(moduleDeps).filter(count => count > 5).length;
  stats.highFanOutList = Object.entries(moduleDeps)
    .filter(([, count]) => count > 5)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 5)
    .map(([file, count]) => {
      const module = modules.find(m => m.path === file);
      return { module: module?.module || path.basename(file), count };
    });
  
  // Feature coupling
  const crossFeatureModules = modules.filter(m => 
    Array.isArray(m.domain) ? m.domain.length > 1 : false
  ).length;
  stats.featureCoupling = (crossFeatureModules / modules.length) * 100;
  
  // Risk distribution
  const totalRisk = Object.values(stats.riskCounts).reduce((a, b) => a + b, 0);
  stats.riskDistribution = Object.entries(stats.riskCounts)
    .map(([risk, count]) => `${risk}:${((count/totalRisk)*100).toFixed(0)}%`)
    .join(' ');
  
  // Stability stats
  stats.stabilityStats = modules.reduce((acc, m) => {
    const stability = m.stability || 'UNKNOWN';
    acc[stability] = (acc[stability] || 0) + 1;
    return acc;
  }, {});
  
  stats.recentChangesImpact = "Run `git log --oneline -10` to see recent changes affecting system architecture.";
  
  return stats;
}

function getHealthIndicator(value, lowThreshold, highThreshold) {
  if (value < lowThreshold) return 'ðŸŸ¢ HEALTHY';
  if (value < highThreshold) return 'ðŸŸ¡ MONITOR';
  return 'ðŸ”´ HIGH';
}

function generateFeatureTable(featureStats) {
  const headers = '| Feature | Modules | Hooks | Events | Primary Risk |';
  const separator = '|---|---|---|---|---|';
  
  const rows = featureStats.map(stat => {
    const primaryRisk = Object.entries(stat.risk)
      .sort(([,a], [,b]) => b - a)[0]?.[0] || 'UNKNOWN';
    
    return `| **${stat.feature}** | ${stat.modules} | ${stat.hooks} | ${stat.events} | ${primaryRisk} |`;
  }).join('\n');
  
  return `${headers}\n${separator}\n${rows}`;
}

function generateTopDependencies(dependencyStats) {
  return dependencyStats.slice(0, 5)
    .map(([dep, count]) => `- **${dep}**: ${count} usages`)
    .join('\n') || '- None found';
}

function isRiskBalanced(riskCounts) {
  const total = Object.values(riskCounts).reduce((a, b) => a + b, 0);
  const highRisk = (riskCounts.HIGH || 0) + (riskCounts.CRITICAL || 0);
  return (highRisk / total) < 0.3; // Less than 30% high risk
}

function generateActionItems(stats, exportStats = {}) {
  const items = [];
  
  if (stats.highRiskModules > 10) {
    items.push('ðŸ”´ **HIGH PRIORITY**: Reduce high-risk modules count - consider refactoring or adding safety measures');
  }
  
  if (stats.featureCoupling > 40) {
    items.push('ðŸŸ¡ **MEDIUM**: High feature coupling detected - review module boundaries');
  }
  
  if (stats.highFanOutModules > 5) {
    items.push('ðŸŸ¡ **MEDIUM**: Multiple modules with high dependency fan-out - review architecture');
  }
  
  if ((stats.totalHooks / stats.totalModules) > 4) {
    items.push('ðŸŸ¡ **MEDIUM**: High hook density - consider consolidating hook usage');
  }
  
  if (stats.stabilityStats.UNKNOWN > (stats.totalModules * 0.3)) {
    items.push('ðŸŸ¢ **LOW**: Add stability annotations to module headers');
  }
  
  // Export performance action items
  if (parseFloat(exportStats.averageJobTime || 0) > 3000) {
    items.push('ðŸ”´ **HIGH PRIORITY**: Export jobs are slow (>3s) - optimize export pipeline');
  }
  
  if ((exportStats.activeMutexes || 0) > 5) {
    items.push('ðŸŸ¡ **MEDIUM**: High concurrent export load - consider queue management');
  }
  
  if (parseFloat(exportStats.cacheHitPercentage || 0) < 10 && (exportStats.totalJobs || 0) > 20) {
    items.push('ðŸŸ¡ **MEDIUM**: Low export cache efficiency - review idempotency settings');
  }
  
  if ((exportStats.cacheSize || 0) > 40) {
    items.push('ðŸŸ¢ **LOW**: Export cache is full - consider increasing TTL cleanup frequency');
  }
  
  return items.length > 0 ? items.join('\n') : 'ðŸŸ¢ **No immediate action items** - System appears healthy';
}

/**
 * Genera statistiche di idempotenza export
 * @returns {Object} Statistiche export
 */
function generateExportIdempotencyStats() {
  // Per ora usiamo dati simulati, in futuro si puÃ² esporre via API
  // o leggere da file di log del sistema di idempotenza
  try {
    // Tenta di leggere statistiche da un eventuale file di cache
    // In produzione questo potrebbe essere esposto via API REST
    const mockStats = {
      totalJobs: 0,
      duplicatesPrevented: 0,
      cacheHits: 0,
      averageJobTime: 0,
      activeMutexes: 0,
      cacheSize: 0,
      duplicatePercentage: '0.0',
      cacheHitPercentage: '0.0',
      averageJobTimeFormatted: '0ms'
    };
    
    // TODO: In futuro, implementare lettura da:
    // 1. File di log dell'IdempotencyManager
    // 2. API endpoint per statistiche real-time
    // 3. Database per metriche storiche
    
    return mockStats;
    
  } catch (error) {
    console.warn('Export idempotency stats not available:', error.message);
    return {
      totalJobs: 0,
      duplicatesPrevented: 0,
      cacheHits: 0,
      averageJobTime: 0,
      activeMutexes: 0,
      cacheSize: 0,
      duplicatePercentage: '0.0',
      cacheHitPercentage: '0.0',
      averageJobTimeFormatted: '0ms'
    };
  }
}

export { generateSystemStatus, calculateSystemStats, generateExportIdempotencyStats };